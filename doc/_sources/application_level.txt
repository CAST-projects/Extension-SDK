Running code after analyzers
============================

.. note::
    This is documentation for cast.application version 1.5.0.
    This API can be upgraded separately from AIP. 


After all analysis job have ran some code can be launched on the resulting knowledge base. 

During this step, you :

* can create new links
* can decorate existing objects or links with new properties
* can create new violations on objects
* has access to all objects and links created by any analyzer
* have access to source code



Implementing An application level extension
-------------------------------------------

A plugin can be called at the end of analysis by implementing a subclass of 

.. autoclass:: cast.application.ApplicationLevelExtension
   :members: 


For example::

    import cast.application
    import logging
    
    class ExtensionApplication(cast.application.ApplicationLevelExtension):
    
        def end_application(self, application):
        
            logging.debug("running code at the end of an application")
            
            application.sql_tool("/* put your sql code here*/")
            application.update_cast_knowledge_base("/* put your sql code here*/")



It is better to separate code from application level extension from the analyser level extension. They use separate python API and separate process 
launching.

A plugin can contain any number of ApplicationLevelExtension, they all will be called back.

Those call backs have the application as context :

.. autoclass:: cast.application.Application



Objects
-------

Objects from the applications will all be of class : 

.. autoclass:: cast.application.Object

   .. automethod:: cast.application.Object.get_name

   .. automethod:: cast.application.Object.get_fullname

   .. automethod:: cast.application.Object.get_qualified_name

   .. automethod:: cast.application.Object.get_type

   .. automethod:: cast.application.Object.get_property

   .. automethod:: cast.application.Object.get_positions

We provide a high level classification of Objects :

   .. automethod:: cast.application.Object.is_file
   .. automethod:: cast.application.Object.is_program
   .. automethod:: cast.application.Object.is_class
   .. automethod:: cast.application.Object.is_executable
   .. automethod:: cast.application.Object.is_package
   .. automethod:: cast.application.Object.is_variable
   .. automethod:: cast.application.Object.is_table
   .. automethod:: cast.application.Object.is_index
   .. automethod:: cast.application.Object.is_foreignkey
   .. automethod:: cast.application.Object.is_form
   .. automethod:: cast.application.Object.is_web_service_operation
   .. automethod:: cast.application.Object.is_dbms


Accessing objects
*****************


Objects can be accessed using one of the following methods on :class:`cast.application.Application` :

.. automethod:: cast.application.Application.get_objects

.. automethod:: cast.application.Application.search_objects

.. versionadded:: 1.5.0

.. automethod:: cast.application.Application.objects

This will be the preferred way for querying objects. It returns a  :class:`cast.application.ObjectQuery` that represent a query on objects.
This query can be refined using `method chaining  <https://en.wikipedia.org/wiki/Method_chaining>`_.

.. autoclass:: cast.application.ObjectQuery
   :members: 

Examples::

    # iterate all objects of the application
    for o in application.objects():
        ...
    
    # iterate all java objects of the application
    for o in application.objects().has_type('Java'):
        ...
    
    # iterate all public java objects of the application
    for o in application.objects().has_type('Java').is_public():
        ...


   
Decorating objects
******************

Objects can receive new properties 

   .. automethod:: cast.application.Object.save_property

And violations for quality rules

   .. automethod:: cast.application.Object.save_violation

In either case there are a certain number of preliminary steps to do :

1. having a property applicable for the metamodel type of the object either by : 
  
  a. reusing an existing property of the metamodel
  b. declare a new property in the metamodel of the plugin

2. declare the handling of the property by calling :

.. automethod:: cast.application.Application.declare_property_ownership


Here is a complete sample code, assuming that the property exists::

    # here say that we take in charge to put the value of the property 'CAST_SQL_Object.version' for
    # all objects of type 'CAST_MSTSQL_RelationalTable'
 
    application.declare_property_ownership('CAST_SQL_Object.version',['CAST_MSTSQL_RelationalTable'])
    
    for o in application.objects().has_type('CAST_MSTSQL_RelationalTable'):
        o.save_property('CAST_SQL_Object.version', "my version")


Bookmark
********

All code positions are represented by objects of class :

.. autoclass:: cast.application.Bookmark
   :members: 

Through that class one can access file, file path lines and columns.

Specific object types
*********************

Some objects have specific types with specific accessors :

File
####

Those represent analysed source files.

.. autoclass:: cast.application.File
   :members: 

Files, with their path loaded can be retrieved using :
    
.. automethod:: cast.application.Application.get_files


Project
#######

Those represent result projects (vcproj, jar, dll, .project, pom.xml, ...).

.. autoclass:: cast.application.Project
   :members: 

Database
########

Objects representing analysed databases are represneted by the following class :


.. autoclass:: cast.application.Database
   :members: 


They be retrieved using :

.. automethod:: cast.application.Application.get_databases



Schema
######

.. autoclass:: cast.application.DatabaseOwner
   :members: 



links
-----

.. versionadded:: 1.5.0


Iterating on a :class:`cast.application.LinkQuery` will gives object of type :

.. autoclass:: cast.application.EnlightenLink
   
   .. automethod:: cast.application.EnlightenLink.get_caller
   .. automethod:: cast.application.EnlightenLink.get_callee
   .. automethod:: cast.application.EnlightenLink.get_type_names
   .. automethod:: cast.application.EnlightenLink.get_positions
   .. automethod:: cast.application.EnlightenLink.get_code


Accessing existing links
************************


Already existing links (those created by analysers) can be accessed with 

.. automethod:: cast.application.Application.links


Which creates a :class:`cast.application.LinkQuery` retrieving all links. 
This query can then be refined using the method chaining pattern API.  

.. autoclass:: cast.application.LinkQuery
   :members: 


Examples::

    # iterate all links application
    for link in application.links():
        ...
    
    # iterate all call links of application
    for link in application.links().has_type(LinkType.call): 
        ...
    
    # iterate all call links to java objects of application
    for link in application.links().has_type(LinkType.call).has_callee(application.objects().has_type('Java')):
        ...


Decorating existing links with properties
*****************************************

The same way object can be decorated with new properties, existing links can receive new properties :  

.. automethod:: cast.application.EnlightenLink.save_property

.. note::

    The property must have been declared to be handled by using :meth:`cast.application.Application.declare_property_ownership`


Example::

    links = application.links().has_type(LinkType.call).has_caller(application.objects().has_type('C/C++').is_virtual())
    
    application.declare_property_ownership('physicalLink.inferenceEngineRequests', links)
    
    for link in links:
        
        link.save_property('physicalLink.inferenceEngineRequests', ['virtual call'])
        logging.info('adding property on %s --> %s', link.get_caller().get_qualified_name(), link.get_callee().get_qualified_name())
       

Validating dynamic links
************************

Dynamic links can be marked as validated or ignored.

.. automethod:: cast.application.EnlightenLink.validate

.. automethod:: cast.application.EnlightenLink.ignore

Those methods will flag a link with the corresponding state.
 
Here is an example conversion from DLM Rule Engine to this API::

    # all so called 'dynamic' links 
    for link in application.links().is_not_sure():
        
        callee = link.get_callee()
        
        expression = re.compile(...)
        
        if re.match(expresion,callee.get_fullname()):
            
            link.validate()
        
        

Creating links
**************

New links can be created between two :class:`cast.application.Object`

.. autofunction:: cast.application.create_link

Created links can receive properties :

.. method:: save_property(prop, value)

.. note::

    This time, no need to declare ownership.

Example::

    link = create_link('callLink', o1, o2)
    link.save_property('physicalLink.inferenceEngineRequests', ['virtual call'])

Created links can be marked as uncertain. They are then eligible to Dynamic Link Manager.

.. method:: mark_as_not_sure()

Example::

    link = create_link('callLink', o1, o2)
    link.mark_as_not_sure() # indicate that this link is not certain


A reference finder
------------------

This API includes a simplified reference finder. 

.. warning::
    This API is different from the CAST-MS Reference Finder. 
    
    Here this API only 'finds' references. It creates no object, no links.
    
    Typically : 
    CAST-MS Reference Finder 
    <=> 
    :meth:`cast.application.Application.get_files`
    + :class:`cast.application.ReferenceFinder` 
    + :meth:`cast.application.Application.search_objects`
    + :meth:`cast.application.create_link`


.. autoclass:: cast.application.ReferenceFinder
   :members: 

Basically an object of this class will search one or several patterns in a file, and returns an iterable of :class:`cast.application.Reference` objects that represent the matches found.

Usage sample ::

    rf = ReferenceFinder()
    
    # declare a pattern named 'begin_pattern'
    rf.add_pattern("begin_pattern", before="", element="begin", after="")
    # one can add other patterns in the same reference finder 
    rf.add_pattern("end_pattern", before="", element="end", after="")
    
    # we assume here that f is of type cast.application.File
    references = list(rf.find_references_in_file(f))
    
This works as follow : 

1. the file is opened
2. the text is scanned till one of the pattern matches (the first in the declaring order)
3. apply step 2 on the rest of the text ...  


The result is represented by the following class. Please not that it creates no object in the knowledge base nor any object. 
The 'reaction' to those patterns found is totally open to developer.  


.. class:: cast.application.Reference
   
   A reference found in the code.

   `pattern_name` Name of the found pattern

   `object` object containing the reference

   `value` the text that was matched

   `bookmark` :class:`cast.application.Bookmark` of the reference found


Logging
-------

Use the standard python `logging <https://docs.python.org/3/library/logging.html>`_ module::


    import logging
    
    class ExtensionApplication(cast.application.ApplicationLevelExtension):
    
        def end_application(self, application):
        
            logging.info("hello %s",  'world!')



Using legacy tools
------------------

For the sake of continuity we have kept some of the tools after analysis one can find in CAST-MS.

.. warning::
    
    Those are kept for compatibility. But it is strongly recommended to use programmatic API when possible.  

Running 'tools after analysis'
******************************

The so called 'Cast-MS tools after analysis' are generally used to create missing links from frameworks.
They can be directly used from inside the plugin by using :

* :func:`cast.application.Application.sql_tool`
* :func:`cast.application.Application.update_cast_knowledge_base`

Note that it is strongly recommended to use ansi sql code here. The SQL code will be executed in the correct schema so following code is perfectly working::

    class ExtensionApplication(cast.application.ApplicationLevelExtension):
    
        def end_application(self, application):
        
            application.update_cast_knowledge_base("""
            insert into CI_LINKS (CALLER_ID, CALLED_ID, LINK_TYPE, ERROR_ID) values (1,1,1,0);
            """)

So no need to prefix tables with nothing.


Interactive scripting
---------------------

The API can also be used outside plugins, in a script or in an interactive manner. 

Basically one has to 'connect' to a knowledge base and then can retrieve applications, etc..

.. autoclass:: cast.application.KnowledgeBase
   :members: 
   

Example of a script::

    from cast.application import KnowledgeBase, LinkType
    
    kb = KnowledgeBase('b800_8525_local')
    
    print(kb.get_applications())
    
    application = kb.get_application(name='Cpp')
    
    for link in application.links().has_type([LinkType.call, LinkType.accessExec]).has_callee(application.objects().is_virtual()):
        
        print(link)


Default connection is a css localhost:2280. But any other connection can be passed to the constructor of :class:`cast.application.KnowledgeBase`


.. autofunction:: cast.application.create_postgres_engine
.. autofunction:: cast.application.create_oracle_engine
.. autofunction:: cast.application.create_sqlserver_engine


Example::

    from cast.application import KnowledgeBase, LinkType, create_oracle_engine
    
    engine = create_oracle_engine(user="EXTKB734", password="EXTKB734", host="JNK2O11", port=1521, sid="JNK2O11", service=None)
    
    kb = KnowledgeBase('extkb734', engine=engine)
    
    ...



